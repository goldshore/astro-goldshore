// .Jules/run-conflict-sweeper.jsagent
const fs = require('fs');
const { execSync } = require('child_process');

console.log('Running Jules Conflict Sweeper...');

// Helper to run command and log
function run(cmd) {
    try {
        console.log(`> ${cmd}`);
        execSync(cmd, { stdio: 'inherit' });
    } catch (e) {
        console.error(`Command failed: ${cmd}`);
        throw e;
    }
}

// 1. Detect Lockfile Conflict
// We assume this runs in a context where we might have just pulled or merged
// and want to see if pnpm-lock.yaml is in a bad state or if we just want to regenerate it to be safe.
// Since "Golden Rule" says: "If pnpm-lock.yaml conflicts: delete + regenerate",
// We can check if the file has conflict markers OR just regeneration logic if requested.

// For this sweeper, we'll try to detect if we are in a "conflicted state" regarding lockfile
// by checking if `pnpm install` fails or if the file has markers.

const lockfile = 'pnpm-lock.yaml';

let hasConflict = false;
if (fs.existsSync(lockfile)) {
    const content = fs.readFileSync(lockfile, 'utf8');
    if (content.includes('<<<<<<<')) {
        hasConflict = true;
        console.log('Detected conflict markers in pnpm-lock.yaml');
    }
}

if (hasConflict || process.env.FORCE_REGENERATE_LOCKFILE) {
    console.log('Regenerating lockfile per Golden Rule 0.1...');
    try {
        if (fs.existsSync(lockfile)) fs.unlinkSync(lockfile);
        if (fs.existsSync('node_modules')) fs.rmSync('node_modules', { recursive: true, force: true });

        run('pnpm install');

        // If in a git repo, stage it?
        // We leave committing to the caller (GitHub Action or user)
        console.log('✅ Lockfile regenerated.');
    } catch (e) {
        console.error('❌ Failed to regenerate lockfile.');
        process.exit(1);
    }
} else {
    console.log('No lockfile conflict detected. Skipping regeneration.');
}
