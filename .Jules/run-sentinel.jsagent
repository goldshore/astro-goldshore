// .Jules/run-sentinel.jsagent
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('Running Jules Sentinel Checks...');

const RULES = {
  maxFiles: 20,
  maxApps: 2,
  highConflictFiles: [
    'pnpm-lock.yaml',
    'pnpm-workspace.yaml',
    'turbo.json',
    'package.json',
    'tsconfig.json',
    'wrangler.toml',
    'astro.config.mjs'
  ]
};

// --- Check 1: Merge Markers ---
console.log('1. Checking for merge markers...');
try {
  // grep returns 0 if match found (which means failure for us), 1 if no match (success)
  // We exclude this file itself from grep to avoid false positives
  // Also excluding .Jules/ directory as it contains scripts checking for these markers
  // And ops/ directory as it contains documentation about markers
  execSync('grep -r "<<<<<<<" . --exclude-dir=node_modules --exclude-dir=.git --exclude-dir=.Jules --exclude-dir=ops');
  console.error('‚ùå Merge markers found! Please resolve conflicts before pushing.');
  process.exit(1);
} catch (e) {
  // grep returns exit code 1 when no matches found, which is what we want
  console.log('‚úÖ No merge markers found.');
}

// --- Specific Fixers ---

function fixUnpinnedActions(fileContent) {
    let modified = false;
    let newContent = fileContent.replace(/uses:\s+([^\s]+)@(v[^\s]+)/g, (match, action, tag) => {
        if (tag.match(/^[0-9a-f]{40}$/)) return match;
        try {
            if (action.startsWith('./')) return match;
            const remote = `https://github.com/${action.split('/')[0]}/${action.split('/')[1]}`;
            const output = run(`git ls-remote ${remote} ${tag}`, { ignoreError: true });
            if (output) {
                const sha = output.split('\t')[0];
                if (sha && sha.match(/^[0-9a-f]{40}$/)) {
                    modified = true;
                    return `uses: ${action}@${sha} # ${tag}`;
                }
            }
        } catch (e) {
            log(`Failed to resolve SHA for ${action}@${tag}`, 'WARN');
        }
        return match;
    });
    return { modified, content: newContent };
}

function fixAstroDuplicates(content) {
    // Strategy: Favor the HEAD version (user changes) but clean up conflict markers.
    // Ensure we don't end up with duplicate frontmatter if both sides added imports.
    const conflictRegex = /<<<<<<< HEAD\n([\s\S]*?)\n=======\n[\s\S]*?>>>>>>> [^\n]*/g;
    let modified = false;
    let newContent = content;

    if (content.match(conflictRegex)) {
        newContent = content.replace(conflictRegex, (match, headContent) => {
            modified = true;
            return headContent;
        });
    }

    // Additional check: Duplicate frontmatter blocks (--- ... --- ... ---)
    // This simple check just ensures we don't have multiple blocks if regex failed or if manual merge left them.
    // For now, reliance on conflict marker resolution is safer than aggressive parsing.

    return { modified, content: newContent };
}

function fixDeadTodos(content) {
    // Removes TODOs that are unreachable or obsolete
    const regex = /(return\s+[^;]+;)\s*\/\/\s*TODO[^\n]*/g;
    let modified = false;
    let newContent = content.replace(regex, (match, ret) => {
        modified = true;
        return ret;
    });
    return { modified, content: newContent };
}

function fixEnvTypes(content, filePath) {
    if (content.includes(': Env') || content.includes('<Env>')) {
        if (!content.includes('interface Env') && !content.includes('type Env') && !content.includes('import type { Env }')) {
             if (filePath.endsWith('.ts') || filePath.endsWith('.js')) {
                 const importStmt = "import type { Env } from '@cloudflare/workers-types';\n";
                 return { modified: true, content: importStmt + content };
             }
        }
    }
    return { modified: false, content };
}

function fixMissingImports(content, filePath) {
    const importRegex = /import\s+.*?\s+from\s+['"](\..*?)['"]/g;
    let modified = false;
    let match;

    while ((match = importRegex.exec(content)) !== null) {
        const importPath = match[1];
        try {
            const dir = path.dirname(filePath);
            const resolved = path.resolve(dir, importPath);
            const extensions = ['.ts', '.js', '.astro', '.tsx', '.jsx', '.json', ''];
            let exists = false;
            for (const ext of extensions) {
                if (fs.existsSync(resolved + ext) || (fs.existsSync(resolved) && fs.existsSync(path.join(resolved, 'index' + ext)))) {
                    exists = true;
                    break;
                }
            }

            if (!exists) {
                // If path already has extension, use it, else default to .ts
                let newFile = resolved;
                if (!path.extname(newFile)) {
                    newFile += '.ts';
                }

                log(`Creating missing module: ${newFile}`, 'ACTION');
                fs.mkdirSync(path.dirname(newFile), { recursive: true });
                fs.writeFileSync(newFile, '// Sentinel: Generated stub for missing module\nexport {};\n');
                modified = true;
            }
        } catch (e) {}
    }
    return { modified, content };
// --- Check 2: Lockfile Consistency ---
// This is a basic check. If git status shows pnpm-lock.yaml as modified but not committed, or having conflict markers.
// The grep check above catches conflict markers.
// Here we might check if lockfile is missing (though pnpm install should fix that).
if (!fs.existsSync('pnpm-lock.yaml')) {
    console.error('‚ùå pnpm-lock.yaml is missing!');
    process.exit(1);
}
console.log('‚úÖ Lockfile present.');

// --- Check 3: PR Scoping (Only runs if PR context is available via git diff) ---
// We try to determine changed files against main
try {
    const changedFiles = execSync('git diff --name-only origin/main...HEAD').toString().trim().split('\n').filter(Boolean);

    // Get list of conflicted files
    const conflictedFiles = run('git diff --name-only --diff-filter=U', { ignoreError: true }).split('\n').filter(Boolean);

    // 1. Lockfile Conflicts
    if (conflictedFiles.includes('pnpm-lock.yaml')) {
        log('Resolving pnpm-lock.yaml conflict...', 'ACTION');
        try { fs.unlinkSync('pnpm-lock.yaml'); } catch(e) {}
        run('rm -rf node_modules', { ignoreError: true });
        run('pnpm install', { ignoreError: true });
        resolvedFiles.push('pnpm-lock.yaml');
        run('git add pnpm-lock.yaml');
    }

    // 2. Process other files
    for (const file of conflictedFiles) {
        if (file === 'pnpm-lock.yaml') continue; // Handled above
        if (!fs.existsSync(file)) continue;

        let content = fs.readFileSync(file, 'utf8');
        let fileModified = false;

        // Astro Duplicates
        if (file.endsWith('.astro')) {
            const res = fixAstroDuplicates(content);
            if (res.modified) { content = res.content; fileModified = true; }
        }

        // Unpinned Actions
        if (file.startsWith('.github/workflows/')) {
            const res = fixUnpinnedActions(content);
            if (res.modified) { content = res.content; fileModified = true; }
        }

        // Env Types
        const resEnv = fixEnvTypes(content, file);
        if (resEnv.modified) { content = resEnv.content; fileModified = true; }

        // Dead TODOs
        const resTodo = fixDeadTodos(content);
        if (resTodo.modified) { content = resTodo.content; fileModified = true; }

        // Missing Imports (Side effect: creates files)
        const resImports = fixMissingImports(content, file);
        if (resImports.modified) { }

        if (fileModified) {
            fs.writeFileSync(file, content);
            resolvedFiles.push(file);
            run(`git add "${file}"`);
        }
    }

    return resolvedFiles;
}

// --- Main Flows ---

async function fetchOpenPRs() {
    log('Fetching open PRs...');
    const prs = await githubRequest('GET', `/repos/${OWNER}/${REPO}/pulls?state=open`);
    if (!Array.isArray(prs)) return [];

    const candidates = [];
    for (const pr of prs) {
        // Detailed check to get mergeable_state
        const detailed = await githubRequest('GET', `/repos/${OWNER}/${REPO}/pulls/${pr.number}`);
        if (detailed.mergeable_state === 'dirty') {
            candidates.push(detailed);
        }
    }
    return candidates;
}

async function processPR(pr, reportObj) {
    if (pr.head.repo.full_name !== `${OWNER}/${REPO}`) {
        log(`Skipping fork PR #${pr.number} from ${pr.head.repo.full_name}`, 'WARN');
        return;
    }

    const branch = pr.head.ref;
    log(`Processing dirty PR #${pr.number} (${branch})...`, 'INFO');

    try {
        run(`git fetch origin ${branch}`);
        run(`git checkout ${branch}`);

        // Step 2: Rebase/Merge
        try {
            run(`git fetch origin main`);
            run(`git rebase origin/main`);
        } catch (e) {
            log('Rebase failed due to conflicts. Attempting resolution...', 'WARN');
            run(`git rebase --abort`, { ignoreError: true });

            // Fallback to merge to expose conflict markers for resolution
            try {
                 run(`git merge origin/main`);
            } catch (mergeError) {
                // Merge failed (expected), proceed to resolve
            }
        }

        // Step 3: Resolve Mechanical Conflicts
        const fixedFiles = resolveMechanicalConflicts();

        if (fixedFiles.length > 0) {
            run(`git add .`); // Ensure generated files are added
            run(`git commit -m "Sentinel: resolve merge conflicts and pin actions"`);
        }

        // Step 4: Verify Build & Lint
        try {
            log('Verifying build...', 'INFO');
            run('pnpm lint');
            run('pnpm build');
        } catch (e) {
            log('Verification failed. Reverting changes...', 'ERROR');
            // Revert changes
            run(`git reset --hard origin/${branch}`);

            await githubRequest('POST', `/repos/${OWNER}/${REPO}/issues/${pr.number}/labels`, { labels: ['needs-codex'] });
            await githubRequest('POST', `/repos/${OWNER}/${REPO}/issues/${pr.number}/comments`, {
                body: `üõ°Ô∏è **Sentinel Report**\n\nAutomated resolution failed build/lint verification. Changes reverted. Handing off to Codex.`
            });
            reportObj.failures.push({ pr: pr.number, reason: 'Verification failed' });
            return;
        }

        // Step 5: Push
        log('Pushing changes...', 'ACTION');
        run(`git push --force-with-lease origin ${branch}`);

        // Step 6: Document
        await githubRequest('POST', `/repos/${OWNER}/${REPO}/issues/${pr.number}/comments`, {
            body: `üõ°Ô∏è **Sentinel Report**\n\nResolved merge conflicts and applied hygiene fixes.\n\n**Files touched:**\n${fixedFiles.map(f => `- ${f}`).join('\n')}`
        });
        reportObj.resolved.push({ pr: pr.number, files: fixedFiles });

    } catch (e) {
        log(`Failed to process ${branch}: ${e.message}`, 'ERROR');
        // If critical failure, ensure we don't leave mess?
        // We are in a script, next iteration might reset.
        await githubRequest('POST', `/repos/${OWNER}/${REPO}/issues/${pr.number}/labels`, { labels: ['needs-codex'] });
        reportObj.failures.push({ pr: pr.number, reason: e.message });
    }
}

async function runSweep() {
    const report = { timestamp: new Date().toISOString(), resolved: [], failures: [] };
    const dirtyPRs = await fetchOpenPRs();
    log(`Found ${dirtyPRs.length} dirty PRs.`);

    for (const pr of dirtyPRs) {
        await processPR(pr, report);
    }
    writeReport(report);
}

async function runPRMode() {
    const report = { timestamp: new Date().toISOString(), resolved: [], failures: [] };
    const branch = process.env.GITHUB_HEAD_REF || run('git rev-parse --abbrev-ref HEAD');

    // In PR mode, we might not have the PR number easily if not passed.
    // GitHub Actions event payload has it.
    let prNumber = null;
    if (process.env.GITHUB_EVENT_PATH) {
        try {
            const event = require(process.env.GITHUB_EVENT_PATH);
            prNumber = event.pull_request ? event.pull_request.number : null;
        } catch (e) {}
    }

    if (prNumber) {
        const pr = { number: prNumber, head: { ref: branch, repo: { full_name: `${OWNER}/${REPO}` } } };
        // We need 'mergeable_state' check?
        // In PR mode, we just want to run sentinel on *this* PR.
        // But the logic above relies on checking mergeable_state to confirm it's dirty?
        // If triggered by sentinel-pr.yml, it runs on 'opened', 'synchronize'.
        // We should just run processPR.
        await processPR(pr, report);
    } else {
        log('No PR number found in environment.', 'WARN');
    }
    writeReport(report);
}

// --- Main ---
(async () => {
    try {
        if (MODE === 'SWEEP') {
            await runSweep();
        } else {
            await runPRMode();
        }
    } catch (e) {
        console.error(e);
        process.exit(1);
    }
})();
    if (changedFiles.length > RULES.maxFiles) {
        console.warn(`‚ö†Ô∏è  PR Size Warning: ${changedFiles.length} files changed (Limit: ${RULES.maxFiles}). Consider splitting.`);
    } else {
        console.log(`‚úÖ PR size ok (${changedFiles.length} files).`);
    }

    const highConflictTouched = changedFiles.filter(f =>
        RULES.highConflictFiles.some(hcf => f.endsWith(hcf))
    );

    if (highConflictTouched.length > 0) {
        console.warn(`‚ö†Ô∏è  High-conflict files touched: ${highConflictTouched.join(', ')}. Please merge "infra PRs" quickly.`);
    }

} catch (e) {
    console.log('‚ÑπÔ∏è  Could not determine changed files (not in a git repo or no origin/main). Skipping scoping checks.');
}

console.log('Sentinel checks passed.');
