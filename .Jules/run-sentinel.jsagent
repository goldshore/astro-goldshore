#!/usr/bin/env node
/**
 * .Jules/run-sentinel.jsagent
 *
 * Sentinel orchestrates hygiene checks for PRs and nightly sweeps.
 * It applies safe mechanical fixes (rebases, action pinning, lockfile regeneration)
 * and reports anything that still requires Codex intervention.
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const https = require('https');

// --- Configuration ---
const ARGS = process.argv.slice(2);
const MODE = ARGS.includes('--mode=sweep') ? 'SWEEP' : 'PR';
const AUTO_FIX = ARGS.includes('--fix') || MODE === 'SWEEP';
const REPORT_FILE = '.Jules/sentinel-report.json';

const CONFIG = {
  ignoreDirs: ['node_modules', '.git', 'dist', '.turbo', '.astro', '.Jules', 'ops'],
  extensions: ['.js', '.ts', '.astro', '.yml', '.yaml', '.json', '.mjs'],
  highConflictFiles: [
    'pnpm-lock.yaml',
    'pnpm-workspace.yaml',
    'turbo.json',
    'package.json',
    'tsconfig.json',
    'wrangler.toml',
    'astro.config.mjs'
  ]
};
const REPORT_FILE = '.jules/guard/report.json';
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;

// --- Utilities ---
function log(msg, type = 'info') {
  const icon = { info: 'â„¹ï¸', success: 'âœ…', warning: 'âš ï¸', error: 'âŒ', action: 'ðŸ”§' }[type] || '';
  console.log(`${icon} [${new Date().toISOString().split('T')[1].split('.')[0]}] ${msg}`);
}

function run(cmd, { ignoreError = false, inherit = false } = {}) {
  try {
    return execSync(cmd, { stdio: inherit ? 'inherit' : 'pipe', encoding: 'utf-8' }).trim();
  } catch (e) {
    if (!ignoreError) {
      console.error(`Failed: ${cmd}`);
      console.error(e.message);
    }
    throw e;
  }
}

function git(args, ignoreError = false) {
  return run(`git ${args}`, { ignoreError });
}

function writeReport(report) {
  fs.mkdirSync(path.dirname(REPORT_FILE), { recursive: true });
  fs.writeFileSync(REPORT_FILE, JSON.stringify(report, null, 2));
}

function getBranchName() {
  try {
    return git('rev-parse --abbrev-ref HEAD');
  } catch (e) {
    return 'unknown';
  }
}

function sanitizeBranch(branch) {
  if (!branch || !/^[a-zA-Z0-9_\-\/.]+$/.test(branch)) {
      throw new Error(`Invalid branch name: ${branch}`);
  }
  return branch;
}

function getLatestShaForAction(actionRef, tag) {
  try {
    const remote = `https://github.com/${actionRef}`;
    const lsRemote = git(`ls-remote ${remote} ${tag} refs/tags/${tag}*`, true);
    if (!lsRemote) return null;
    return lsRemote.split('\t')[0];
  } catch (e) {
    return null;
  }
}

function fixUnpinnedActions(filePath, content) {
  let modified = false;
  const regex = /uses:\s+([a-zA-Z0-9_\-\/]+)@(v[0-9]+(\.[0-9]+)*)/g;

  const newContent = content.replace(regex, (fullMatch, action, tag) => {
    const sha = getLatestShaForAction(action, tag);
    if (sha) {
      log(`Pinning ${action}@${tag} -> ${sha}`, 'action');
      modified = true;
      return `uses: ${action}@${sha} # ${tag}`;
    }
    return fullMatch;
  });

  if (modified) {
    fs.writeFileSync(filePath, newContent);
  }
  return modified;
}

function regenerateLockfile() {
  log('Regenerating pnpm-lock.yaml...', 'action');
  try {
    if (fs.existsSync('pnpm-lock.yaml')) fs.unlinkSync('pnpm-lock.yaml');
    if (fs.existsSync('node_modules')) fs.rmSync('node_modules', { recursive: true, force: true });
    run('pnpm install', { inherit: true });
    return true;
  } catch (e) {
    log('Failed to regenerate lockfile', 'error');
    return false;
  }
}

// --- Checks ---

const CHECKS = {
  nestedLockfiles: (file, content) => {
    const absFile = path.resolve(file);
    const absRoot = path.resolve('pnpm-lock.yaml');

    if (path.basename(file) === 'pnpm-lock.yaml' && absFile !== absRoot) return ['Nested pnpm-lock.yaml found'];
    if (['package-lock.json', 'yarn.lock'].includes(path.basename(file))) return [`Forbidden lockfile: ${path.basename(file)}`];
    return [];
  },
  unpinnedActions: (file, content) => {
    if (!file.endsWith('.yml') && !file.endsWith('.yaml')) return [];
    if (content.match(/uses:\s+([a-zA-Z0-9_\-\/]+)@(v[0-9]+(\.[0-9]+)*)/)) {
      return ['Unpinned GitHub Actions found'];
    }
    return [];
  },
  mergeMarkers: (file, content) => {
    const START = '<<<<' + '<<<';
    const MID = '====' + '===';
    if (content.includes(START) && content.includes(MID)) return ['Merge markers found'];
    return [];
  }
};

function buildFileList(baseDir = '.') {
  const ignore = CONFIG.ignoreDirs.map((dir) => `-not -path "*/${dir}/*"`).join(' ');
  const cmd = `find ${baseDir} -type f ${ignore}`;
  return run(cmd)
    .split('\n')
    .filter(Boolean)
    .filter((file) => CONFIG.extensions.some((ext) => file.endsWith(ext)) || !CONFIG.extensions.length);
}

function scanAndFix(dir = '.') {
  const report = {};
  const files = buildFileList(dir);
  let fixedCount = 0;

  for (const file of files) {
    let content = '';
    try {
      content = fs.readFileSync(file, 'utf-8');
    } catch (e) {
      continue;
    }

    const issues = [];

    const markerIssues = CHECKS.mergeMarkers(file, content);
    if (markerIssues.length > 0) issues.push(...markerIssues);

    if (CHECKS.unpinnedActions(file, content).length > 0) {
      if (AUTO_FIX) {
        if (fixUnpinnedActions(file, content)) {
          fixedCount++;
        }
      } else {
        issues.push('Unpinned GitHub Actions');
      }
    }

    const lockIssues = CHECKS.nestedLockfiles(file, content);
    if (lockIssues.length > 0) {
      issues.push(...lockIssues);
      if (AUTO_FIX) {
        fs.unlinkSync(file);
        log(`Deleted forbidden file: ${file}`, 'action');
        fixedCount++;
      }
    }

    if (issues.length > 0 && !AUTO_FIX) {
      report[file] = issues;
    }
  }

  return { report, fixedCount };
}

function collectConflictFiles() {
  const conflicts = git('diff --name-only --diff-filter=U', true);
  return conflicts ? conflicts.split('\n').filter(Boolean) : [];
}

        // 4. Dead TODOs
        if (modified || content.includes('TODO')) {
            const newContent = content.replace(/(return\s*.*;)\s*(\/\/|\/\*)\s*TODO[\s\S]*?(\n|$)/g, '$1\n');
            if (newContent !== content) {
                content = newContent;
                modified = true;
            }
        }

        // 5. Missing Imports Check & Creation
        const importRegex = /import\s+.*?\s+from\s+['"](\..*?)['"]/g;
        let match;
        while ((match = importRegex.exec(content)) !== null) {
            const importPath = match[1];
            try {
                const dir = path.dirname(file);
                const resolvedPathWithoutExt = path.resolve(dir, importPath);

function buildBaseReport() {
  return {
    mode: MODE,
    autoFix: AUTO_FIX,
    branch: getBranchName(),
    timestamp: new Date().toISOString(),
    issues: {},
    fixedFiles: [],
    highConflictTouches: [],
    branchesProcessed: [],
    needsCodex: [],
    failures: []
  };
}

async function runPRCheck() {
  log('Running PR Sentinel check...');
  const report = buildBaseReport();

  if (!fs.existsSync('pnpm-lock.yaml')) {
    report.failures.push('pnpm-lock.yaml missing');
    if (AUTO_FIX && regenerateLockfile()) {
      report.fixedFiles.push('pnpm-lock.yaml');
    }
  }

  const conflictFiles = collectConflictFiles();
  if (conflictFiles.length > 0) {
    report.needsCodex.push({ branch: report.branch, reason: 'Unresolved merge conflicts', files: conflictFiles });
  }

  const { report: issues, fixedCount } = scanAndFix('.');
  report.issues = issues;
  if (fixedCount > 0) report.fixedFiles.push(`${fixedCount} files auto-fixed`);

  try {
    const changed = git('diff --name-only origin/main...HEAD', true);
    if (changed) {
      const files = changed.split('\n').filter(Boolean);
      report.highConflictTouches = files.filter((f) => CONFIG.highConflictFiles.some((h) => f.endsWith(h)));
    }
  } catch (e) {
    log('Skipping scope checks (no git context).', 'warning');
  }

  writeReport(report);

  const unresolvedIssues = Object.keys(report.issues).length > 0 || report.needsCodex.length > 0 || report.failures.length > 0;
  if (unresolvedIssues) {
    log('Sentinel detected issues that require attention.', 'error');
    console.log(JSON.stringify(report, null, 2));
    process.exit(1);
  }

  log('PR Sentinel checks passed.', 'success');
}

function attemptRebase(branch) {
  try {
    git(`rebase origin/main`);
    return { success: true, conflicts: [] };
  } catch (e) {
    const conflictFiles = collectConflictFiles();
    return { success: false, conflicts: conflictFiles };
  }
}

function sweepBranch(branch) {
  const branchReport = { branch, fixed: [], conflicts: [], pushed: false };

  git(`checkout -B ${branch} origin/${branch}`);

  const rebaseResult = attemptRebase(branch);
  if (!rebaseResult.success) {
    branchReport.conflicts = rebaseResult.conflicts;

    if (rebaseResult.conflicts.length === 1 && rebaseResult.conflicts[0] === 'pnpm-lock.yaml') {
      log(`Lockfile conflict detected on ${branch}. Regenerating...`, 'warning');
      if (regenerateLockfile()) {
        git('add pnpm-lock.yaml');
        try {
          git('rebase --continue');
          branchReport.fixed.push('pnpm-lock.yaml');
        } catch (continueErr) {
          git('rebase --abort', true);
          return { ...branchReport, aborted: true };
        }
      }
    } else {
      git('rebase --abort', true);
      return { ...branchReport, aborted: true };
    }
  }

  const scanResult = scanAndFix('.');
  if (scanResult.fixedCount > 0) {
    branchReport.fixed.push(`${scanResult.fixedCount} files auto-fixed`);
  }

  const status = git('status --porcelain');
  if (status) {
    git('add .');
    git('commit -m "chore: Sentinel auto-fix"', true);
    git(`push origin ${branch} --force-with-lease`, true);
    branchReport.pushed = true;
  }

  return branchReport;
}

async function runSweep() {
  log('Running Sentinel sweep across remote branches...', 'action');
  const report = buildBaseReport();

  git('fetch --all');

  const branches = git('branch -r')
    .split('\n')
    .map((b) => b.trim().replace('origin/', ''))
    .filter((b) => b && b !== 'main' && b !== 'HEAD' && !b.includes('->'));

  for (const branch of branches) {
    try {
      const branchReport = sweepBranch(branch);
      report.branchesProcessed.push(branchReport);

      if (branchReport.aborted) {
        report.needsCodex.push({ branch, reason: 'Rebase conflict', files: branchReport.conflicts });
      }
    } catch (e) {
      log(`Failed processing ${branch}: ${e.message}`, 'error');
      report.failures.push({ branch, error: e.message });
      try { git('rebase --abort', true); } catch (_) {}
      try { git('checkout .', true); } catch (_) {}
    }
  }

  writeReport(report);
  log(`Sweep complete. Report written to ${REPORT_FILE}`, 'success');
}

(async () => {
  try {
    if (MODE === 'SWEEP') {
      await runSweep();
    } else {
      await runPRCheck();
    }
  } catch (e) {
    console.error(e);
    process.exit(1);
  }
})();
