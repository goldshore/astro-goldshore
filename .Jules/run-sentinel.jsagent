// .Jules/run-sentinel.jsagent
const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

console.log('Running Jules Sentinel Checks...');

const RULES = {
  maxFiles: 20,
  maxApps: 2,
  highConflictFiles: [
    'pnpm-lock.yaml',
    'pnpm-workspace.yaml',
    'turbo.json',
    'package.json',
    'tsconfig.json',
    'wrangler.toml',
    'astro.config.mjs'
  ]
};

// --- Check 1: Merge Markers ---
console.log('1. Checking for merge markers...');
try {
  // grep returns 0 if match found (which means failure for us), 1 if no match (success)
  // We exclude this file itself from grep to avoid false positives
  // Also excluding .Jules/ directory as it contains scripts checking for these markers
  // And ops/ directory as it contains documentation about markers
  execSync('grep -r "<<<<<<<" . --exclude-dir=node_modules --exclude-dir=.git --exclude-dir=.Jules --exclude-dir=ops');
  console.error('❌ Merge markers found! Please resolve conflicts before pushing.');
  process.exit(1);
} catch (e) {
  // grep returns exit code 1 when no matches found, which is what we want
  console.log('✅ No merge markers found.');
}

// --- Check 2: Lockfile Consistency ---
// This is a basic check. If git status shows pnpm-lock.yaml as modified but not committed, or having conflict markers.
// The grep check above catches conflict markers.
// Here we might check if lockfile is missing (though pnpm install should fix that).
if (!fs.existsSync('pnpm-lock.yaml')) {
    console.error('❌ pnpm-lock.yaml is missing!');
    process.exit(1);
}
console.log('✅ Lockfile present.');

// --- Check 3: PR Scoping (Only runs if PR context is available via git diff) ---
// We try to determine changed files against main
try {
    const changedFiles = execSync('git diff --name-only origin/main...HEAD').toString().trim().split('\n').filter(Boolean);

    if (changedFiles.length > RULES.maxFiles) {
        console.warn(`⚠️  PR Size Warning: ${changedFiles.length} files changed (Limit: ${RULES.maxFiles}). Consider splitting.`);
    } else {
        console.log(`✅ PR size ok (${changedFiles.length} files).`);
    }

    const highConflictTouched = changedFiles.filter(f =>
        RULES.highConflictFiles.some(hcf => f.endsWith(hcf))
    );

    if (highConflictTouched.length > 0) {
        console.warn(`⚠️  High-conflict files touched: ${highConflictTouched.join(', ')}. Please merge "infra PRs" quickly.`);
    }

} catch (e) {
    console.log('ℹ️  Could not determine changed files (not in a git repo or no origin/main). Skipping scoping checks.');
}

console.log('Sentinel checks passed.');
// Configuration
const CONFIG = {
  ignoreDirs: ['node_modules', '.git', 'dist', '.turbo', '.astro'],
  extensions: ['.js', '.ts', '.astro', '.yml', '.yaml', '.json'],
};

// Utilities
function run(cmd, ignoreError = false) {
  try {
    return execSync(cmd, { stdio: 'pipe', encoding: 'utf-8' }).trim();
  } catch (e) {
    if (!ignoreError) console.error(`Failed: ${cmd}`, e.message);
    return null;
  }
}

function listFiles(dir) {
  let results = [];
  const list = fs.readdirSync(dir);
  list.forEach(file => {
    const filePath = path.join(dir, file);
    const stat = fs.statSync(filePath);
    if (stat && stat.isDirectory()) {
      if (!CONFIG.ignoreDirs.includes(file)) {
        results = results.concat(listFiles(filePath));
      }
    } else {
      if (CONFIG.extensions.includes(path.extname(file))) {
        results.push(filePath);
      }
    }
  });
  return results;
}

// Checks
const CHECKS = {
  unpinnedActions: {
    name: "Unpinned GitHub Actions",
    regex: /uses:\s+([a-zA-Z0-9_\-\/]+)@(v[0-9]+(\.[0-9]+)*)/g,
    check: (content, filePath) => {
      if (!filePath.endsWith('.yml') && !filePath.endsWith('.yaml')) return [];
      const matches = [];
      let match;
      while ((match = CHECKS.unpinnedActions.regex.exec(content)) !== null) {
        matches.push({
          line: content.substring(0, match.index).split('\n').length,
          match: match[0],
          action: match[1],
          version: match[2]
        });
      }
      return matches;
    }
  },
  multipleAstroBlocks: {
    name: "Multiple Astro Component Definitions",
    check: (content, filePath) => {
      if (!filePath.endsWith('.astro')) return [];
      const fenceCount = (content.match(/^---/gm) || []).length;
      if (fenceCount > 2) {
          return [{ message: `Found ${fenceCount} '---' fences. Expected <= 2.` }];
      }
      return [];
    }
  },
  missingEnvTypes: {
    name: "Missing Env Types",
    check: (content, filePath) => {
      if (!filePath.endsWith('.ts') && !filePath.endsWith('.astro')) return [];
      if (content.includes('Env') && !content.includes('interface Env') && !content.includes('import') && !content.includes('/// <reference')) {
        return [];
      }
      return [];
    }
  },
  nestedLockfiles: {
    name: "Nested Lockfiles",
    check: (content, filePath) => {
        if (path.basename(filePath) === 'pnpm-lock.yaml' && filePath !== 'pnpm-lock.yaml') {
            return [{ message: "Nested pnpm-lock.yaml found." }];
        }
        if (path.basename(filePath) === 'package-lock.json' || path.basename(filePath) === 'yarn.lock') {
            return [{ message: `Forbidden lockfile found: ${path.basename(filePath)}` }];
        }
        return [];
    }
  }
};

// Main
async function main() {
  console.log("Starting Sentinel (Repo Doctor)...");

  const files = listFiles('.');
  const report = {};
  let fail = false;

  for (const file of files) {
    const content = fs.readFileSync(file, 'utf-8');

    // Check Nested Lockfiles
    const lockfileErrors = CHECKS.nestedLockfiles.check(content, file);
    if (lockfileErrors.length > 0) {
        report[file] = (report[file] || []).concat(lockfileErrors);
        fail = true;
    }

    // Unpinned Actions
    const unpinned = CHECKS.unpinnedActions.check(content, file);
    if (unpinned.length > 0) {
        report[file] = (report[file] || []).concat(unpinned.map(u => ({ message: `Unpinned action: ${u.match}` })));
    }

    // Astro Blocks
    const astro = CHECKS.multipleAstroBlocks.check(content, file);
    if (astro.length > 0) {
        report[file] = (report[file] || []).concat(astro);
        fail = true;
    }
  }

  // Output Report
  if (Object.keys(report).length > 0) {
    console.log("\n=== Sentinel Report ===");
    for (const [file, issues] of Object.entries(report)) {
      console.log(`\nFile: ${file}`);
      issues.forEach(i => console.log(`  - ${i.message}`));
    }

    if (fail) process.exit(1);
  } else {
    console.log("No issues found.");
  }
}

main().catch(console.error);
