/**
 * Jules Daily Guardian Runner
 * - discovers branches
 * - checks out each branch
 * - runs install/build/lint/test/typecheck (using Turbo via pnpm)
 * - runs deep sanity checks (Workspace, Wrangler, Astro, Artifacts)
 * - applies safe fixes
 * - opens PRs/issues
 */

const { execSync } = require("node:child_process");
const fs = require("node:fs");
const path = require("node:path");

// --- Configurable constants ---
const MAX_BRANCH_AGE_DAYS = 90;
const MAX_BRANCH_AGE_DAYS = 90;
// --- Helpers ---

// --- Helpers ---
function sh(cmd, cwd = process.cwd()) {
  try {
    return execSync(cmd, { stdio: "pipe", cwd, maxBuffer: 1024 * 1024 * 10 }).toString("utf8").trim();
  } catch (e) {
    const err = new Error(`Command failed: ${cmd}\n${e.stderr ? e.stderr.toString() : e.message}`);
    err.stdout = e.stdout ? e.stdout.toString() : "";
    throw err;
  }
}

function hasScript(pkgPath, scriptName) {
  try {
    if (!fs.existsSync(pkgPath)) return false;
    const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
    return Boolean(pkg.scripts && pkg.scripts[scriptName]);
  } catch {
    return false;
  }
}

function run(cmd, allowFail = false) {
  try {
    return { ok: true, out: sh(cmd) };
  } catch (e) {
    if (allowFail) return { ok: false, out: String(e.stdout || e.message) };
    throw e;
  }
}

// --- Git / Branch Logic ---

function listBranches() {
  sh("git fetch --all --prune");
  const raw = sh("git for-each-ref --format='%(refname:short)' refs/remotes/origin");
  return raw
    .split("\n")
    .map((b) => b.replace(/^origin\//, ""))
    .filter((b) => b && b !== "HEAD");
}

function branchAgeDays(branch) {
  try {
    const ts = sh(`git log -1 --format=%ct origin/${branch}`);
    const ageMs = Date.now() - Number(ts) * 1000;
    return Math.floor(ageMs / (1000 * 60 * 60 * 24));
  } catch (e) {
      return 9999;
  }
}

function prioritySort(branches) {
  const isRelease = (b) => b.startsWith("release/");
  const isFeature = (b) => b.startsWith("feature/");
  return branches.sort((a, b) => {
    const score = (x) => {
      if (x === "main") return 0;
      if (isRelease(x)) return 1;
      if (x === "develop") return 2;
      if (isFeature(x)) return 3;
      return 4;
    };
    const sa = score(a), sb = score(b);
    if (sa !== sb) return sa - sb;

    // Newer first
    let ta = 0, tb = 0;
    try { ta = Number(sh(`git log -1 --format=%ct origin/${a}`)); } catch {}
    try { tb = Number(sh(`git log -1 --format=%ct origin/${b}`)); } catch {}
    return tb - ta;
  });
}

function shouldSkip(branch) {
  const age = branchAgeDays(branch);
  return age > MAX_BRANCH_AGE_DAYS;
  if (branch.startsWith("release/")) return false;
  return age > MAX_BRANCH_AGE_DAYS;
}

function checkout(branch) {
  sh(`git checkout -B jules/${branch} origin/${branch}`);
}

// --- Deep Sanity Checks ---

function checkWorkspaceIntegrity() {
  const findings = [];
  const root = process.cwd();
     let dirEntries;
  function deepScan(dir) {
        dirEntries = fs.readdirSync(dir, { withFileTypes: true });
     try {
        dirEntries = fs.readdirSync(dir, { withFileTypes: true });
     } catch (e) {
        return;
     for (const ent of dirEntries) {

     for (const ent of dirEntries) {
         if (ent.name === "node_modules") continue;
         const fullPath = path.join(dir, ent.name);
         const relPath = path.relative(root, fullPath);

         if (ent.isDirectory()) {
             if (ent.name === ".git") {
                 if (dir !== root) {
                     findings.push(`Nested .git found: ${relPath}`);
                 }
                 continue;
             }
             if (relPath.includes("astro-goldshore/astro-goldshore")) {
                 findings.push(`Recursive path detected: ${relPath}`);
             }
             deepScan(fullPath);
         } else {
             if (dir !== root) {
                 if (ent.name === "pnpm-workspace.yaml") findings.push(`Nested pnpm-workspace found: ${relPath}`);
                 if (ent.name === "turbo.json") findings.push(`Nested turbo.json found: ${relPath}`);
                 if (ent.name === "package.json") {
                     try {
                         const pkg = JSON.parse(fs.readFileSync(fullPath, "utf8"));
                         if (pkg.workspaces) findings.push(`Nested root package.json (has workspaces) found: ${relPath}`);
                     } catch {}
                 }
             }
         }
     }
  }

  deepScan(root);
  return findings;
}

function checkWranglerSanity() {
    const findings = [];
    let files = [];
    try {
        files = sh("find . -type f -name 'wrangler.toml' -not -path '*/node_modules/*'")
            .split("\n").filter(Boolean);
    } catch { return ["Failed to scan for wrangler.toml"]; }

    for (const f of files) {
        const content = fs.readFileSync(f, "utf8");
        const missing = [];
        if (!/^name\s*=/m.test(content)) missing.push("name");
        if (!/^main\s*=/m.test(content)) missing.push("main");
        if (!/^compatibility_date\s*=/m.test(content)) missing.push("compatibility_date");

        if (missing.length > 0) {
            findings.push(`File ${f} missing keys: ${missing.join(", ")}`);
        }

        // Warn if routes missing
        if (!/^routes\s*=/m.test(content) && !/^route\s*=/m.test(content)) {
            findings.push(`File ${f} missing 'routes' or 'route' key (warning)`);
        }

        const secrets = ["CF_API_TOKEN", "CLOUDFLARE_API_TOKEN", "ACCOUNT_ID", "SECRET", "PRIVATE_KEY"];
        for (const s of secrets) {
            if (content.match(new RegExp(`^${s}\\s*=`, "mi"))) {
                 findings.push(`Potential secret ${s} found in ${f}`);
            }
        }
    }
    return findings;
}

function checkAstroSanity() {
    const findings = [];
    let configs = [];
    try {
        configs = sh("find . -type f \\( -name 'astro.config.mjs' -o -name 'astro.config.ts' -o -name 'astro.config.js' \\) -not -path '*/node_modules/*'")
            .split("\n").filter(Boolean);
    } catch { return ["Failed to scan for astro.config"]; }

    for (const f of configs) {
        const content = fs.readFileSync(f, "utf8");
        const dir = path.dirname(f);

        // Check adapter if @astrojs/cloudflare dependency exists
        const pkgPath = path.join(dir, "package.json");
        if (fs.existsSync(pkgPath)) {
            try {
                const pkg = JSON.parse(fs.readFileSync(pkgPath, "utf8"));
                const deps = { ...pkg.dependencies, ...pkg.devDependencies };

                if (deps["@astrojs/cloudflare"]) {
                    if (!content.includes("@astrojs/cloudflare")) {
                        findings.push(`${f}: Has @astrojs/cloudflare dep but config doesn't seem to import it.`);
                    }
                }
            } catch {}
        }

        // Check env.d.ts
        const envPath = path.join(dir, "src/env.d.ts");
        const srcPath = path.join(dir, "src");
        if (fs.existsSync(srcPath) && !fs.existsSync(envPath)) {
             findings.push(`${dir}: Missing src/env.d.ts for Astro project`);
        }
    }

    // Check .astro committed
    try {
        const dotAstro = sh("git ls-files .astro/").split("\n").filter(Boolean);
        if (dotAstro.length > 0) {
            findings.push(`Committed .astro/ files detected: ${dotAstro.length} files`);
        }
    } catch {}

    return findings;
}

function checkGeneratedArtifacts() {
    const findings = [];
    try {
        const ignored = sh("git ls-files -ci --exclude-standard").split("\n").filter(Boolean);
        if (ignored.length > 0) {
            findings.push(`Tracked files that are ignored: ${ignored.length} files (will auto-fix)`);
        }
    } catch {}
    return findings;
}


// --- Main Runner ---

function runChecks() {
  const results = {};
  results.pnpm = run("pnpm -v", true);

  const forceRecursive = process.env.JULES_FORCE_RECURSIVE === "1";

  // Install
  results.install = run("pnpm install --frozen-lockfile", true);
  if (!results.install.ok) {
    results.install_fallback = run("pnpm install", true);
  }

  // Build
  if (forceRecursive) {
      results.build = run("pnpm -r build", true);
  } else {
      results.build = run("pnpm build", true);
  }

  // Scripts
  const rootPkg = "package.json";

  if (hasScript(rootPkg, "lint")) {
      results.lint = run("pnpm lint", true);
  } else if (forceRecursive) {
      results.lint = run("pnpm -r lint", true);
  }

  if (hasScript(rootPkg, "test")) {
      results.test = run("pnpm test", true);
  } else if (forceRecursive) {
      results.test = run("pnpm -r test", true);
  }

  if (hasScript(rootPkg, "typecheck")) {
      results.typecheck = run("pnpm typecheck", true);
  } else if (forceRecursive) {
      results.typecheck = run("pnpm -r typecheck", true);
  }

  // Deep Checks
  results.workspace_integrity = checkWorkspaceIntegrity();
  results.wrangler_sanity = checkWranglerSanity();
  results.astro_sanity = checkAstroSanity();
  results.artifacts = checkGeneratedArtifacts();

  return results;
}

function applySafeFixes() {
  const forceRecursive = process.env.JULES_FORCE_RECURSIVE === "1";

  // Format
  if (hasScript("package.json", "format")) {
      run("pnpm format", true);
  } else if (forceRecursive) {
      run("pnpm -r format", true);
  }

  // Lint fix
  if (hasScript("package.json", "lint")) {
      run("pnpm lint -- --fix", true);
  } else if (forceRecursive) {
      run("pnpm -r lint --fix", true);
  }

  // Remove tracked ignored files
  try {
      const ignoredFiles = sh("git ls-files -ci --exclude-standard");
      if (ignoredFiles) {
          sh("git ls-files -ci --exclude-standard -z | xargs -0 -r git rm -r --cached");
      }
  } catch (e) {
      // console.error("Failed to clean ignored files:", e.message);
  }

  // Ensure .gitignore exists
  if (!fs.existsSync(".gitignore")) {
    fs.writeFileSync(".gitignore", "# Add ignores here\n");
  }
}

function hasChanges() {
  const status = sh("git status --porcelain");
  return status.length > 0;
}

function commitChanges(branch) {
  sh("git add -A");
  sh(`git commit -m "chore(daily): repo health sweep [${branch}]"`);
}

function pushBranch(branch) {
  sh(`git push -u origin HEAD:jules/daily-${branch.replace(/\//g, "-")}`);
}

async function main() {
  // Mode: Check current dir only (for dev/CI single branch or verification)
  if (process.argv.includes("--check-only")) {
      console.log("Running in check-only mode...");
      const results = runChecks();
      console.log(JSON.stringify(results, null, 2));
      return;
  }

  const branches = prioritySort(listBranches());

  for (const branch of branches) {
    if (shouldSkip(branch)) continue;

    try {
        console.log(`Processing branch: ${branch}`);
        checkout(branch);

        const before = runChecks();
        applySafeFixes();
        const after = runChecks();

        if (hasChanges()) {
          commitChanges(branch);
          pushBranch(branch);

          console.log(`OPEN_PR: jules/daily-${branch.replace(/\//g, "-")} -> ${branch}`);
          console.log({ before, after });
        } else {
          console.log(`NO_CHANGES: ${branch}`);
          console.log({ before });
        }
    } catch (err) {
        console.error(`FAILED branch ${branch}:`, err);
    }
  }
}

main().catch((e) => {
  console.error(e);
  process.exit(1);
});
